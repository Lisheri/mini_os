/* 
    rust 操作系统开发
*/
// no_std 标识, 由于要开发一个操作系统, 因此需要解除和标准库的链接
// 现在的 crate 还是隐式的和标准库进行了链接, 因此需要带上 no_std 标识
#![no_std]
#![no_main] // 告诉Rust编译器我们不使用预定义的入口点


use core::panic::PanicInfo;

// 增加panic处理函数, 这还是因为panic也是来源于标准库的一部分导致的
// panic_handler 属性定义了一个函数，它会在一个 panic 发生时被调用。
// 而在标准库中有自己的处理函数
// 实现自己的 panic_handler, 不需要太多的实现, 只需要有这样一个东西即可
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    // ? "!" 为发散函数标记, 发散函数的返回类型称作 Never 类型(称作 !)
    loop {}
}

// 语言项是一些编译器需求的特殊函数或类型
// 比如 Copy trait 就是一个语言项, 告诉编译器哪些类型需要遵循 复制语义
// ! 正常情况下严禁实现自己的语言项, 因为它是高度不稳定的, 它不会经过编译器类型检查(因此编译器甚至不能确保他们的类型是正确的)

// ? 当然, 我们也有相对稳定的方式修复上面(最开始实现的panic函数)的语言项错误
// ? eh_personality 语言项标记的函数, 将被用于实现栈展开
// ? 在使用Rust标准库的情况下, 当panic发生时, Rust将使用栈展开, 来运行所有栈上活跃变量的 "析构函数(destructor)"
// 这确保了所有使用的内存都被释放，允许调用程序的父进程（parent thread）捕获 panic
// - 当然, "栈展开" 是一个复杂的过程, 比如Linux的 libunwind 或 windows的 结构化异常处理, 通常需要依赖操作系统的库
// - 但是我们在实现一个简易版操作系统, 因此不在这里使用它
// - 当然, 栈展开并不是迫切需求的功能, 因此这里我们直接禁用它
// - Rust 提供了在 panic 时中止（abort on panic）的选项, 能够禁用栈展开相关的标志信息生成, 也因此能够缩小生成二进制程序的长度
// - 最简单的方式就是在 Cargo.toml 中增加 panic = "abort"(映射一下环境变量)


// 上面事情做完以后, 进行构建时会提示错误: requires "start" lang_item
// 意味着程序失去了 "start" 语言项, 用于定位程序的入口点
// 通常会认为程序运行时首先被调用是main, 但是其实大多数语言都拥有运行时系统(runtime system), 区别只是大小(比如java的GC或者go的协程)
// 这些 runtime-system 都需要在main函数执行前启动
// 在使用标准库时, Rust程序是从一个名为 crt0(C runtime zero) 的运行时库开始的。
// 它能够建立一个适合C语言程序运行的环境。
// 在这之后, 这个运行时库会调用 Rust的运行时入口点, 这个入口点被称为 start语言项("start" language item)
// 对于Rust来说, 他虽然对外宣传无运行时, 但其实只是因为他的运行时非常小而已, 几乎可以忽略, 被设计为只拥有极少的功能, 比如爆栈检测和打印栈轨迹, 之后, 运行时将会调用main函数
// 由于独立式可执行程序并不能访问 Rust运行时 或者 crt0 库, 所以我们需要定义自己的入口点。
// 但只实现一个 start 语言项是不够的, 因为在这之后程序依然会要求 ctr0库, 因此, 这里需要做的事情是重写整个 crt0 库和它定义的入口点


// ! ------------ 重写入口点 ------------

// - 1. 顶部增加标识: #![no_main], 告诉Rust不再使用预定义的入口点main
// - 2. 移除main函数, 由于没有底层运行时调用它, 因此main函数也就没有存在的必要了
// - 3. 使用 no_mangle 标记下面的函数, 对它禁用名称重整, 保证rust编译器输出一个名为 _start 的函数, 否则编译器可能最终生成名为 _ZN3blog_os4_start7hb173fedf945531caE 的函数, 无法让链接正确识别
// - 4. 标记 "extern C", 告诉编译器这个函数应当使用 C语言的调用约定, 而不是 Rust语言的调用约定
// - 5. 函数名为 _start ，是因为大多数系统默认使用这个名字作为入口点名称。
// - 6. 依然返回 "发散函数", 因为这个入口不会被任何其他函数调用, 但是将会直接被 操作系统 或者 引导程序 调用
// 所以作为函数返回的替代，这个入口点应该去调用，比如操作系统提供的 exit 系统调用（“exit” system call）函数
// 在我们编写操作系统的情况下，关机应该是一个合适的选择，因为当一个独立式可执行程序返回时，不会留下任何需要做的事情
// 现在来看，暂时可以添加一个无限循环，来满足对返回值类型的需求。
#[no_mangle]
pub extern "C" fn _start() -> ! {
    loop {}
}

// 现在依然不能编译, 因为会出现一大段 链接器错误(linker error)

// ! ------------ 重写入口点 ------------



// ! ------------ 链接器错误 ------------
// 链接器 是一个程序, 它将生成的目标文件组合为一个可执行的文件。
// 不同的操作系统规定了不同的可执行文件格式, 因此也有各自不同的 链接器, 抛出不同的错误
// 不过这些错误的原因是一样的: 链接器的默认配置假定程序依赖于C语言的运行时环境, 但当前程序并不依赖它
// 为了解决这个错误, 需要告诉链接器, 它不应该包含C语音运行时环境。
// - 可以选择提供特定的 链接器参数， 也可以选择编译为 裸机目标(bare metal target)
// ! ------------ 链接器错误 ------------



// ! ------------ 编译为裸机目标 ------------
// 在默认情况下，Rust 尝试适配当前的系统环境，编译可执行程序
// 比如当前正在使用 x86_64 平台的 Windows 系统，Rust 将尝试编译一个扩展名为 .exe 的 Windows 可执行程序，并使用 x86_64 指令集。
// 这个环境又被称作为你的宿主系统（“host” system）。
// 为了描述不同的环境，Rust 使用一个称为目标三元组（target triple）的字符串。要查看当前系统的目标三元组，我们可以运行 rustc --version --verbose：

// - rustc 1.70.0 (90c541806 2023-05-31)
// - binary: rustc
// - commit-hash: 90c541806f23a127002de5b4038be731ba1458ca
// - commit-date: 2023-05-31
// - host: aarch64-apple-darwin
// - release: 1.70.0
// - LLVM version: 16.0.2

// 其中 host 字段的值为三元组 aarch64-apple-darwin， 它包含了 CPU 架构 aarch64 , 操作系统(也是供应商) apple  和二进制接口 darwin。(windows上打印还有一个操作系统linux)

// 于是在默认编译时, Rust编译器尝试为当前系统的三元组编译, 并假定底层有一个类似 Windows, Linux或者macos的操作系统提供C语言运行环境 ———— 然而这将会导致链接器错误
// 因此为了避开这个错误, 可以选择另一个底层没有操作系统的运行时环境(裸机环境)
// ? 例如目标三元组 thumbv7em-none-eabihf 描述了一个 ARM 嵌入式系统（embedded system）。
// ? 暂时不需要了解细节, 只需要知道这个环境底层没有操作系统
// ? 这是由三元组中的 none 描述的

// 要为这个目标编译, 需要使用 rustup 添加它: rustup target add thumbv7em-none-eabihf
// 这行命令将为目标下载一个标准库和 core 库。这之后，我们就能为这个目标构建独立式可执行程序了： cargo build --target thumbv7em-none-eabihf

// 由于传递了 --target, 来为裸机目标系统交叉编译当前程序, 目标不包含操作系统, 所以链接器不会试着链接 C 语言运行环境, 因此构建过程会成功完成，不会产生链接器错误。
// ! ------------ 编译为裸机目标 ------------
